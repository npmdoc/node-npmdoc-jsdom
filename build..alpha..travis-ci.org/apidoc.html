<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/tmpvar/jsdom#readme"

    >jsdom (v9.12.0)</a>
</h1>
<h4>A JavaScript implementation of the DOM and HTML standards</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdom">module jsdom</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.jsdom">
            function <span class="apidocSignatureSpan"></span>jsdom
            <span class="apidocSignatureSpan">(html, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.blobToBuffer">
            function <span class="apidocSignatureSpan">jsdom.</span>blobToBuffer
            <span class="apidocSignatureSpan">(blob)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.changeURL">
            function <span class="apidocSignatureSpan">jsdom.</span>changeURL
            <span class="apidocSignatureSpan">(window, urlString)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.createCookieJar">
            function <span class="apidocSignatureSpan">jsdom.</span>createCookieJar
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.createVirtualConsole">
            function <span class="apidocSignatureSpan">jsdom.</span>createVirtualConsole
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.env">
            function <span class="apidocSignatureSpan">jsdom.</span>env
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.evalVMScript">
            function <span class="apidocSignatureSpan">jsdom.</span>evalVMScript
            <span class="apidocSignatureSpan">(window, script)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.getVirtualConsole">
            function <span class="apidocSignatureSpan">jsdom.</span>getVirtualConsole
            <span class="apidocSignatureSpan">(window)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.jQueryify">
            function <span class="apidocSignatureSpan">jsdom.</span>jQueryify
            <span class="apidocSignatureSpan">(window, jqueryUrl, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.nodeLocation">
            function <span class="apidocSignatureSpan">jsdom.</span>nodeLocation
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.reconfigureWindow">
            function <span class="apidocSignatureSpan">jsdom.</span>reconfigureWindow
            <span class="apidocSignatureSpan">(window, newProps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.serializeDocument">
            function <span class="apidocSignatureSpan">jsdom.</span>serializeDocument
            <span class="apidocSignatureSpan">(doc)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsdom.</span>defaultDocumentFeatures</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdom.blobToBuffer">module jsdom.blobToBuffer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.blobToBuffer.blobToBuffer">
            function <span class="apidocSignatureSpan">jsdom.</span>blobToBuffer
            <span class="apidocSignatureSpan">(blob)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdom.changeURL">module jsdom.changeURL</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.changeURL.changeURL">
            function <span class="apidocSignatureSpan">jsdom.</span>changeURL
            <span class="apidocSignatureSpan">(window, urlString)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdom.createCookieJar">module jsdom.createCookieJar</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.createCookieJar.createCookieJar">
            function <span class="apidocSignatureSpan">jsdom.</span>createCookieJar
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdom.createVirtualConsole">module jsdom.createVirtualConsole</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.createVirtualConsole.createVirtualConsole">
            function <span class="apidocSignatureSpan">jsdom.</span>createVirtualConsole
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdom.env">module jsdom.env</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.env.env">
            function <span class="apidocSignatureSpan">jsdom.</span>env
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdom.evalVMScript">module jsdom.evalVMScript</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.evalVMScript.evalVMScript">
            function <span class="apidocSignatureSpan">jsdom.</span>evalVMScript
            <span class="apidocSignatureSpan">(window, script)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdom.getVirtualConsole">module jsdom.getVirtualConsole</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.getVirtualConsole.getVirtualConsole">
            function <span class="apidocSignatureSpan">jsdom.</span>getVirtualConsole
            <span class="apidocSignatureSpan">(window)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdom.jQueryify">module jsdom.jQueryify</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.jQueryify.jQueryify">
            function <span class="apidocSignatureSpan">jsdom.</span>jQueryify
            <span class="apidocSignatureSpan">(window, jqueryUrl, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdom.jsdom">module jsdom.jsdom</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.jsdom.jsdom">
            function <span class="apidocSignatureSpan">jsdom.</span>jsdom
            <span class="apidocSignatureSpan">(html, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.jsdom.env">
            function <span class="apidocSignatureSpan">jsdom.jsdom.</span>env
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.jsdom.jQueryify">
            function <span class="apidocSignatureSpan">jsdom.jsdom.</span>jQueryify
            <span class="apidocSignatureSpan">(window, jqueryUrl, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdom.nodeLocation">module jsdom.nodeLocation</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.nodeLocation.nodeLocation">
            function <span class="apidocSignatureSpan">jsdom.</span>nodeLocation
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdom.reconfigureWindow">module jsdom.reconfigureWindow</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.reconfigureWindow.reconfigureWindow">
            function <span class="apidocSignatureSpan">jsdom.</span>reconfigureWindow
            <span class="apidocSignatureSpan">(window, newProps)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdom.serializeDocument">module jsdom.serializeDocument</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdom.serializeDocument.serializeDocument">
            function <span class="apidocSignatureSpan">jsdom.</span>serializeDocument
            <span class="apidocSignatureSpan">(doc)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdom" id="apidoc.module.jsdom">module jsdom</a></h1>


    <h2>
        <a href="#apidoc.element.jsdom.jsdom" id="apidoc.element.jsdom.jsdom">
        function <span class="apidocSignatureSpan"></span>jsdom
        <span class="apidocSignatureSpan">(html, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsdom = function (html, options) {
  if (options === undefined) {
    options = {};
  }
  if (options.parsingMode === undefined || options.parsingMode === &#x22;auto&#x22;) {
    options.parsingMode = &#x22;html&#x22;;
  }

  if (options.parsingMode !== &#x22;html&#x22; &#x26;&#x26; options.parsingMode !== &#x22;xml&#x22;) {
    throw new RangeError(`Invalid parsingMode option ${JSON.stringify(options.parsingMode)}; must be either &#x22;html&#x22;, ` +
      `&#x22;xml&#x22;, &#x22;auto&#x22;, or undefined`);
  }

  options.encoding = options.encoding || &#x22;UTF-8&#x22;;

  setGlobalDefaultConfig(options);

  // Back-compat hack: we have previously suggested nesting these under document, for jsdom.env at least.
  // So we need to support that.
  if (options.document) {
    if (options.document.cookie !== undefined) {
      options.cookie = options.document.cookie;
    }
    if (options.document.referrer !== undefined) {
      options.referrer = options.document.referrer;
    }
  }

  // List options explicitly to be clear which are passed through
  const window = new Window({
    parsingMode: options.parsingMode,
    contentType: options.contentType,
    encoding: options.encoding,
    parser: options.parser,
    url: options.url,
    lastModified: options.lastModified,
    referrer: options.referrer,
    cookieJar: options.cookieJar,
    cookie: options.cookie,
    resourceLoader: options.resourceLoader,
    deferClose: options.deferClose,
    concurrentNodeIterators: options.concurrentNodeIterators,
    virtualConsole: options.virtualConsole,
    pool: options.pool,
    agent: options.agent,
    agentClass: options.agentClass,
    agentOptions: options.agentOptions,
    strictSSL: options.strictSSL,
    proxy: options.proxy,
    userAgent: options.userAgent
  });

  const documentImpl = idlUtils.implForWrapper(window.document);
  documentFeatures.applyDocumentFeatures(documentImpl, options.features);

  if (options.created) {
    options.created(null, window.document.defaultView);
  }

  if (options.parsingMode === &#x22;html&#x22;) {
    if (html === undefined || html === &#x22;&#x22;) {
      html = &#x22;&#x3c;html&#x3e;&#x3c;head&#x3e;&#x3c;/head&#x3e;&#x3c;body&#x3e;&#x3c;/body&#x3e;&#x3c;/html&#x3e;&#x22;;
    }

    window.document.write(html);
  } else if (options.parsingMode === &#x22;xml&#x22;) {
    if (html !== undefined) {
      documentImpl._htmlToDom.appendHtmlToDocument(html, documentImpl);
    }
  }

  if (window.document.close &#x26;&#x26; !options.deferClose) {
    window.document.close();
  }

  return window.document;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Dealing with asynchronous script loading

If you load scripts asynchronously, e.g. with a module loader like RequireJS, none of the above hooks will really give you what
you want. There&#x27;s nothing, either in jsdom or in browsers, to say &#x22;notify me after all asynchronous loads have completed
.&#x22; The solution is to use the mechanisms of the framework you are using to notify about this finishing up. E.g., with RequireJS
, you could do

```js
// On the Node.js side:
var window = jsdom.<span class="apidocCodeKeywordSpan">jsdom</span>(...).defaultView;
window.onModulesLoaded = function () {
  console.log(&#x22;ready to roll!&#x22;);
};
```

```html
&#x3c;!-- Inside the HTML you supply to jsdom --&#x3e;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdom.blobToBuffer" id="apidoc.element.jsdom.blobToBuffer">
        function <span class="apidocSignatureSpan">jsdom.</span>blobToBuffer
        <span class="apidocSignatureSpan">(blob)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">blobToBuffer = function (blob) {
  return Blob.is(blob) &#x26;&#x26; idlUtils.implForWrapper(blob)._buffer || undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdom.changeURL" id="apidoc.element.jsdom.changeURL">
        function <span class="apidocSignatureSpan">jsdom.</span>changeURL
        <span class="apidocSignatureSpan">(window, urlString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changeURL = function (window, urlString) {
  const doc = idlUtils.implForWrapper(window._document);

  const url = whatwgURL.parseURL(urlString);

  if (url === &#x22;failure&#x22;) {
    throw new TypeError(`Could not parse &#x22;${urlString}&#x22; as a URL`);
  }

  doc._URL = url;
  doc._origin = whatwgURL.serializeURLToUnicodeOrigin(doc._URL);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
In the future we may expand `reconfigureWindow` to allow overriding other `[Unforgeable]` properties. Let us know if you need this
 capability.

#### Changing the URL of an existing jsdom `Window` instance

At present jsdom does not handle navigation (such as setting `window.location.href === &#x22;https://example.com/&#x22;`). However
, if you&#x27;d like to change the URL of an existing `Window` instance (such as for testing purposes), you can use the `jsdom.changeURL
` method:

```js
jsdom.<span class="apidocCodeKeywordSpan">changeURL</span>(window, &#x22;https://example.com/&#x22;);
```

#### Running vm scripts

Although in most cases it&#x27;s simplest to just insert a `&#x3c;script&#x3e;` element or call `window.eval`, in some cases you
 want access to the raw [vm context](https://nodejs.org/api/vm.html) underlying jsdom to run scripts. You can do that like so:

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdom.createCookieJar" id="apidoc.element.jsdom.createCookieJar">
        function <span class="apidocSignatureSpan">jsdom.</span>createCookieJar
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createCookieJar = function () {
  return new CookieJar(null, { looseMode: true });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

- `config.html`: a HTML fragment
- `config.file`: a file which jsdom will load HTML from; the resulting document&#x27;s URL will be a `file://` URL.
- `config.url`: sets the resulting document&#x27;s URL, which is reflected in various properties like `document.URL` and `location
.href`, and is also used for cross-origin request restrictions. If `config.html` and `config.file` are not provided, jsdom will
load HTML from this URL.
- `config.scripts`: see `scripts` above.
- `config.src`: an array of JavaScript strings that will be evaluated against the resulting document. Similar to `scripts`, but
it accepts JavaScript instead of paths/URLs.
- `config.cookieJar`: cookie jar which will be used by document and related resource requests. Can be created by `jsdom.<span class
="apidocCodeKeywordSpan">createCookieJar</span>()` method. Useful to share cookie state among different documents as browsers does
.
- `config.parsingMode`: either `&#x22;auto&#x22;`, `&#x22;html&#x22;`, or `&#x22;xml&#x22;`. The default is `&#x22;auto&#x22;`,
which uses HTML behavior unless `config.url` responds with an XML `Content-Type`, or `config.file` contains a filename ending in
 `.xml` or `.xhtml`. Setting to `&#x22;xml&#x22;` will attempt to parse the document as an XHTML document. (jsdom is [currently
only OK at doing that](https://github.com/tmpvar/jsdom/labels/x%28ht%29ml).)
- `config.referrer`: the new document will have this referrer.
- `config.cookie`: manually set a cookie value, e.g. `&#x27;key=value; expires=Wed, Sep 21 2011 12:00:00 GMT; path=/&#x27;`. Accepts
 cookie string or array of cookie strings.
- `config.headers`: an object giving any headers that will be used while loading the HTML from `config.url`, if applicable.
- `config.userAgent`: the user agent string used in requests; defaults to `Node.js (#process.platform#; U; rv:#process.version#)`
- `config.features`: see Flexibility section below. **Note**: the default feature set for `jsdom.env` does _not_ include fetching
 remote JavaScript and executing it. This is something that you will need to _carefully_ enable yourself.
- `config.resourceLoader`: a function that intercepts subresource requests and allows you to re-route them, modify, or outright
replace them with your own content. More below.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdom.createVirtualConsole" id="apidoc.element.jsdom.createVirtualConsole">
        function <span class="apidocSignatureSpan">jsdom.</span>createVirtualConsole
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createVirtualConsole = function (options) {
  return new VirtualConsole(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  console.error(&#x22;script error!!&#x22;, event.error);
});
```

it is often also desirable to listen for any script errors during initialization, or errors loading scripts passed to `jsdom.env
`. To do this, use the virtual console feature, described in more detail later:

```js
var virtualConsole = jsdom.<span class="apidocCodeKeywordSpan">createVirtualConsole</span>();
virtualConsole.on(&#x22;jsdomError&#x22;, function (error) {
  console.error(error.stack, error.detail);
});

var window = jsdom.jsdom(..., { virtualConsole }).defaultView;
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdom.env" id="apidoc.element.jsdom.env">
        function <span class="apidocSignatureSpan">jsdom.</span>env
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">env = function () {
  const config = getConfigFromArguments(arguments);
  let req = null;

  if (config.file &#x26;&#x26; canReadFilesFromFS) {
    req = resourceLoader.readFile(config.file,
    { defaultEncoding: config.defaultEncoding, detectMetaCharset: true },
    (err, text, res) =&#x3e; {
      if (err) {
        reportInitError(err, config);
        return;
      }

      const contentType = parseContentType(res.headers[&#x22;content-type&#x22;]);
      config.encoding = contentType.get(&#x22;charset&#x22;);
      setParsingModeFromExtension(config, config.file);

      config.html = text;
      processHTML(config);
    });
  } else if (config.html !== undefined) {
    processHTML(config);
  } else if (config.url) {
    req = handleUrl(config);
  } else if (config.somethingToAutodetect !== undefined) {
    const url = URL.parse(config.somethingToAutodetect);
    if (url.protocol &#x26;&#x26; url.hostname) {
      config.url = config.somethingToAutodetect;
      req = handleUrl(config.somethingToAutodetect);
    } else if (canReadFilesFromFS) {
      req = resourceLoader.readFile(config.somethingToAutodetect,
      { defaultEncoding: config.defaultEncoding, detectMetaCharset: true },
      (err, text, res) =&#x3e; {
        if (err) {
          if (err.code === &#x22;ENOENT&#x22; || err.code === &#x22;ENAMETOOLONG&#x22;) {
            config.html = config.somethingToAutodetect;
            processHTML(config);
          } else {
            reportInitError(err, config);
          }
        } else {
          const contentType = parseContentType(res.headers[&#x22;content-type&#x22;]);
          config.encoding = contentType.get(&#x22;charset&#x22;);
          setParsingModeFromExtension(config, config.somethingToAutodetect);

          config.html = text;
          config.url = toFileUrl(config.somethingToAutodetect);
          processHTML(config);
        }
      });
    } else {
      config.html = config.somethingToAutodetect;
      processHTML(config);
    }
  }

  function handleUrl() {
    config.cookieJar = config.cookieJar || exports.createCookieJar();

    const options = {
      defaultEncoding: config.defaultEncoding,
      detectMetaCharset: true,
      headers: config.headers,
      pool: config.pool,
      strictSSL: config.strictSSL,
      proxy: config.proxy,
      cookieJar: config.cookieJar,
      userAgent: config.userAgent,
      agent: config.agent,
      agentClass: config.agentClass,
      agentOptions: config.agentOptions
    };

    const fragment = whatwgURL.parseURL(config.url).fragment;

    return resourceLoader.download(config.url, options, (err, responseText, res) =&#x3e; {
      if (err) {
        reportInitError(err, config);
        return;
      }

      // The use of `res.request.uri.href` ensures that `window.location.href`
      // is updated when `request` follows redirects.
      config.html = responseText;
      config.url = res.request.uri.href;
      if (fragment) {
        config.url += `#${fragment}`;
      }

      if (res.headers[&#x22;last-modified&#x22;]) {
        config.lastModified = new Date(res.headers[&#x22;last-modified&#x22;]);
      }

      const contentType = parseContentType(res.headers[&#x22;content-type&#x22;]);
      if (config.parsingMode === &#x22;auto&#x22;) {
        if (contentType.isXML()) {
          config.parsingMode = &#x22;xml&#x22;;
        }
      }
      config.encoding = contentType.get(&#x22;charset&#x22;);

      processHTML(config);
    });
  }
  return req;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

You can use it with a URL

```js
// Count all of the links from the io.js build page
var jsdom = require(&#x22;jsdom&#x22;);

jsdom.<span class="apidocCodeKeywordSpan">env</span>(
  &#x22;https://iojs.org/dist/&#x22;,
  [&#x22;http://code.jquery.com/jquery.js&#x22;],
  function (err, window) {
    console.log(&#x22;there have been&#x22;, window.$(&#x22;a&#x22;).length - 4, &#x22;io.js releases!&#x22;);
  }
);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdom.evalVMScript" id="apidoc.element.jsdom.evalVMScript">
        function <span class="apidocSignatureSpan">jsdom.</span>evalVMScript
        <span class="apidocSignatureSpan">(window, script)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(window, script) =&#x3e; {
  return script.runInContext(idlUtils.implForWrapper(window._document)._global);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Running vm scripts

Although in most cases it&#x27;s simplest to just insert a `&#x3c;script&#x3e;` element or call `window.eval`, in some cases you
 want access to the raw [vm context](https://nodejs.org/api/vm.html) underlying jsdom to run scripts. You can do that like so:

```js
const script = new vm.Script(&#x22;globalVariable = 5;&#x22;, { filename: &#x22;test.js&#x22; });
jsdom.<span class="apidocCodeKeywordSpan">evalVMScript</span>(window, script);
```

## jsdom vs. PhantomJS

Some people wonder what the differences are between jsdom and [PhantomJS](http://phantomjs.org/), and when you would use one over
 the other. Here we attempt to explain some of the differences, and why we find jsdom to be a pleasure to use for testing and scraping
 use cases.

PhantomJS is a complete browser (although it uses a very old and rare rendering engine). It even performs layout and rendering,
allowing you to query element positions or take a screenshot. jsdom is not a full browser: it does not perform layout or rendering
, and it does not support navigation between pages. It _does_ support the DOM, HTML, canvas, many other web platform APIs, and running
 scripts.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdom.getVirtualConsole" id="apidoc.element.jsdom.getVirtualConsole">
        function <span class="apidocSignatureSpan">jsdom.</span>getVirtualConsole
        <span class="apidocSignatureSpan">(window)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getVirtualConsole = function (window) {
  return window._virtualConsole;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  virtualConsole: virtualConsole
});
```

Post-initialization, if you didn&#x27;t pass in a `virtualConsole` or no longer have a reference to it, you can retrieve the `virtualConsole
` by using:

```js
var virtualConsole = jsdom.<span class="apidocCodeKeywordSpan">getVirtualConsole</span>(window);
```

#### Virtual console `jsdomError` error reporting

Besides the usual events, corresponding to `console` methods, the virtual console is also used for reporting errors from jsdom itself
. This is similar to how error messages often show up in web browser consoles, even if they are not initiated by `console.error`.
So far, the following errors are output this way:

- Errors loading or parsing external resources (scripts, stylesheets, frames, and iframes)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdom.jQueryify" id="apidoc.element.jsdom.jQueryify">
        function <span class="apidocSignatureSpan">jsdom.</span>jQueryify
        <span class="apidocSignatureSpan">(window, jqueryUrl, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jQueryify = function (window, jqueryUrl, callback) {
  if (!window || !window.document) {
    return;
  }

  const implImpl = idlUtils.implForWrapper(window.document.implementation);
  const features = implImpl._features;
  implImpl._addFeature(&#x22;FetchExternalResources&#x22;, [&#x22;script&#x22;]);
  implImpl._addFeature(&#x22;ProcessExternalResources&#x22;, [&#x22;script&#x22;]);

  const scriptEl = window.document.createElement(&#x22;script&#x22;);
  scriptEl.className = &#x22;jsdom&#x22;;
  scriptEl.src = jqueryUrl;
  scriptEl.onload = scriptEl.onerror = () =&#x3e; {
    implImpl._features = features;

    if (callback) {
      callback(window, window.jQuery);
    }
  };

  window.document.body.appendChild(scriptEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### jQueryify

```js
var jsdom = require(&#x22;jsdom&#x22;);
var window = jsdom.jsdom().defaultView;

jsdom.<span class="apidocCodeKeywordSpan">jQueryify</span>(window, &#x22;http://code.jquery.com/jquery-2.1.1.js&#x22;, function () {
  window.$(&#x22;body&#x22;).append(&#x27;&#x3c;div class=&#x22;testing&#x22;&#x3e;Hello World, It works&#x3c;/div&#x3e;&#x27;);

  console.log(window.$(&#x22;.testing&#x22;).text());
});
```

### Passing objects to scripts inside the page
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdom.nodeLocation" id="apidoc.element.jsdom.nodeLocation">
        function <span class="apidocSignatureSpan">jsdom.</span>nodeLocation
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nodeLocation = function (node) {
  return idlUtils.implForWrapper(node)[locationInfo];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  &#x3c;/p&#x3e;`);

var bodyEl = document.body; // implicitly created
var pEl = document.querySelector(&#x22;p&#x22;);
var textNode = pEl.firstChild;
var imgEl = document.querySelector(&#x22;img&#x22;);

console.log(jsdom.<span class="apidocCodeKeywordSpan">nodeLocation</span>(bodyEl));   // null; it&#x27;s not in the source
console.log(jsdom.nodeLocation(pEl));      // { start: 0, end: 39, startTag: ..., endTag: ... }
console.log(jsdom.nodeLocation(textNode)); // { start: 3, end: 13 }
console.log(jsdom.nodeLocation(imgEl));    // { start: 13, end: 32 }
```

This returns the [parse5 location info](https://www.npmjs.com/package/parse5#options-locationinfo) for the node.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdom.reconfigureWindow" id="apidoc.element.jsdom.reconfigureWindow">
        function <span class="apidocSignatureSpan">jsdom.</span>reconfigureWindow
        <span class="apidocSignatureSpan">(window, newProps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reconfigureWindow = function (window, newProps) {
  if (&#x22;top&#x22; in newProps) {
    window._top = newProps.top;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
This returns the [parse5 location info](https://www.npmjs.com/package/parse5#options-locationinfo) for the node.

#### Overriding `window.top`

The `top` property on `window` is marked `[Unforgeable]` in the spec, meaning it is a non-configurable own property and thus cannot
 be overridden or shadowed by normal code running inside the jsdom window, even using `Object.defineProperty`. However, if you&#
x27;re acting from outside the window, e.g. in some test framework that creates jsdom instances, you can override it using the special
 `jsdom.reconfigureWindow` function:

```js
jsdom.<span class="apidocCodeKeywordSpan">reconfigureWindow</span>(window, { top: myFakeTopForTesting });
```

In the future we may expand `reconfigureWindow` to allow overriding other `[Unforgeable]` properties. Let us know if you need this
 capability.

#### Changing the URL of an existing jsdom `Window` instance

At present jsdom does not handle navigation (such as setting `window.location.href === &#x22;https://example.com/&#x22;`). However
, if you&#x27;d like to change the URL of an existing `Window` instance (such as for testing purposes), you can use the `jsdom.changeURL
` method:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdom.serializeDocument" id="apidoc.element.jsdom.serializeDocument">
        function <span class="apidocSignatureSpan">jsdom.</span>serializeDocument
        <span class="apidocSignatureSpan">(doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeDocument = function (doc) {
  return domToHtml([doc]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdom.blobToBuffer" id="apidoc.module.jsdom.blobToBuffer">module jsdom.blobToBuffer</a></h1>


    <h2>
        <a href="#apidoc.element.jsdom.blobToBuffer.blobToBuffer" id="apidoc.element.jsdom.blobToBuffer.blobToBuffer">
        function <span class="apidocSignatureSpan">jsdom.</span>blobToBuffer
        <span class="apidocSignatureSpan">(blob)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">blobToBuffer = function (blob) {
  return Blob.is(blob) &#x26;&#x26; idlUtils.implForWrapper(blob)._buffer || undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdom.changeURL" id="apidoc.module.jsdom.changeURL">module jsdom.changeURL</a></h1>


    <h2>
        <a href="#apidoc.element.jsdom.changeURL.changeURL" id="apidoc.element.jsdom.changeURL.changeURL">
        function <span class="apidocSignatureSpan">jsdom.</span>changeURL
        <span class="apidocSignatureSpan">(window, urlString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changeURL = function (window, urlString) {
  const doc = idlUtils.implForWrapper(window._document);

  const url = whatwgURL.parseURL(urlString);

  if (url === &#x22;failure&#x22;) {
    throw new TypeError(`Could not parse &#x22;${urlString}&#x22; as a URL`);
  }

  doc._URL = url;
  doc._origin = whatwgURL.serializeURLToUnicodeOrigin(doc._URL);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
In the future we may expand `reconfigureWindow` to allow overriding other `[Unforgeable]` properties. Let us know if you need this
 capability.

#### Changing the URL of an existing jsdom `Window` instance

At present jsdom does not handle navigation (such as setting `window.location.href === &#x22;https://example.com/&#x22;`). However
, if you&#x27;d like to change the URL of an existing `Window` instance (such as for testing purposes), you can use the `jsdom.changeURL
` method:

```js
jsdom.<span class="apidocCodeKeywordSpan">changeURL</span>(window, &#x22;https://example.com/&#x22;);
```

#### Running vm scripts

Although in most cases it&#x27;s simplest to just insert a `&#x3c;script&#x3e;` element or call `window.eval`, in some cases you
 want access to the raw [vm context](https://nodejs.org/api/vm.html) underlying jsdom to run scripts. You can do that like so:

```js
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdom.createCookieJar" id="apidoc.module.jsdom.createCookieJar">module jsdom.createCookieJar</a></h1>


    <h2>
        <a href="#apidoc.element.jsdom.createCookieJar.createCookieJar" id="apidoc.element.jsdom.createCookieJar.createCookieJar">
        function <span class="apidocSignatureSpan">jsdom.</span>createCookieJar
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createCookieJar = function () {
  return new CookieJar(null, { looseMode: true });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

- `config.html`: a HTML fragment
- `config.file`: a file which jsdom will load HTML from; the resulting document&#x27;s URL will be a `file://` URL.
- `config.url`: sets the resulting document&#x27;s URL, which is reflected in various properties like `document.URL` and `location
.href`, and is also used for cross-origin request restrictions. If `config.html` and `config.file` are not provided, jsdom will
load HTML from this URL.
- `config.scripts`: see `scripts` above.
- `config.src`: an array of JavaScript strings that will be evaluated against the resulting document. Similar to `scripts`, but
it accepts JavaScript instead of paths/URLs.
- `config.cookieJar`: cookie jar which will be used by document and related resource requests. Can be created by `jsdom.<span class
="apidocCodeKeywordSpan">createCookieJar</span>()` method. Useful to share cookie state among different documents as browsers does
.
- `config.parsingMode`: either `&#x22;auto&#x22;`, `&#x22;html&#x22;`, or `&#x22;xml&#x22;`. The default is `&#x22;auto&#x22;`,
which uses HTML behavior unless `config.url` responds with an XML `Content-Type`, or `config.file` contains a filename ending in
 `.xml` or `.xhtml`. Setting to `&#x22;xml&#x22;` will attempt to parse the document as an XHTML document. (jsdom is [currently
only OK at doing that](https://github.com/tmpvar/jsdom/labels/x%28ht%29ml).)
- `config.referrer`: the new document will have this referrer.
- `config.cookie`: manually set a cookie value, e.g. `&#x27;key=value; expires=Wed, Sep 21 2011 12:00:00 GMT; path=/&#x27;`. Accepts
 cookie string or array of cookie strings.
- `config.headers`: an object giving any headers that will be used while loading the HTML from `config.url`, if applicable.
- `config.userAgent`: the user agent string used in requests; defaults to `Node.js (#process.platform#; U; rv:#process.version#)`
- `config.features`: see Flexibility section below. **Note**: the default feature set for `jsdom.env` does _not_ include fetching
 remote JavaScript and executing it. This is something that you will need to _carefully_ enable yourself.
- `config.resourceLoader`: a function that intercepts subresource requests and allows you to re-route them, modify, or outright
replace them with your own content. More below.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdom.createVirtualConsole" id="apidoc.module.jsdom.createVirtualConsole">module jsdom.createVirtualConsole</a></h1>


    <h2>
        <a href="#apidoc.element.jsdom.createVirtualConsole.createVirtualConsole" id="apidoc.element.jsdom.createVirtualConsole.createVirtualConsole">
        function <span class="apidocSignatureSpan">jsdom.</span>createVirtualConsole
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createVirtualConsole = function (options) {
  return new VirtualConsole(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  console.error(&#x22;script error!!&#x22;, event.error);
});
```

it is often also desirable to listen for any script errors during initialization, or errors loading scripts passed to `jsdom.env
`. To do this, use the virtual console feature, described in more detail later:

```js
var virtualConsole = jsdom.<span class="apidocCodeKeywordSpan">createVirtualConsole</span>();
virtualConsole.on(&#x22;jsdomError&#x22;, function (error) {
  console.error(error.stack, error.detail);
});

var window = jsdom.jsdom(..., { virtualConsole }).defaultView;
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdom.env" id="apidoc.module.jsdom.env">module jsdom.env</a></h1>


    <h2>
        <a href="#apidoc.element.jsdom.env.env" id="apidoc.element.jsdom.env.env">
        function <span class="apidocSignatureSpan">jsdom.</span>env
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">env = function () {
  const config = getConfigFromArguments(arguments);
  let req = null;

  if (config.file &#x26;&#x26; canReadFilesFromFS) {
    req = resourceLoader.readFile(config.file,
    { defaultEncoding: config.defaultEncoding, detectMetaCharset: true },
    (err, text, res) =&#x3e; {
      if (err) {
        reportInitError(err, config);
        return;
      }

      const contentType = parseContentType(res.headers[&#x22;content-type&#x22;]);
      config.encoding = contentType.get(&#x22;charset&#x22;);
      setParsingModeFromExtension(config, config.file);

      config.html = text;
      processHTML(config);
    });
  } else if (config.html !== undefined) {
    processHTML(config);
  } else if (config.url) {
    req = handleUrl(config);
  } else if (config.somethingToAutodetect !== undefined) {
    const url = URL.parse(config.somethingToAutodetect);
    if (url.protocol &#x26;&#x26; url.hostname) {
      config.url = config.somethingToAutodetect;
      req = handleUrl(config.somethingToAutodetect);
    } else if (canReadFilesFromFS) {
      req = resourceLoader.readFile(config.somethingToAutodetect,
      { defaultEncoding: config.defaultEncoding, detectMetaCharset: true },
      (err, text, res) =&#x3e; {
        if (err) {
          if (err.code === &#x22;ENOENT&#x22; || err.code === &#x22;ENAMETOOLONG&#x22;) {
            config.html = config.somethingToAutodetect;
            processHTML(config);
          } else {
            reportInitError(err, config);
          }
        } else {
          const contentType = parseContentType(res.headers[&#x22;content-type&#x22;]);
          config.encoding = contentType.get(&#x22;charset&#x22;);
          setParsingModeFromExtension(config, config.somethingToAutodetect);

          config.html = text;
          config.url = toFileUrl(config.somethingToAutodetect);
          processHTML(config);
        }
      });
    } else {
      config.html = config.somethingToAutodetect;
      processHTML(config);
    }
  }

  function handleUrl() {
    config.cookieJar = config.cookieJar || exports.createCookieJar();

    const options = {
      defaultEncoding: config.defaultEncoding,
      detectMetaCharset: true,
      headers: config.headers,
      pool: config.pool,
      strictSSL: config.strictSSL,
      proxy: config.proxy,
      cookieJar: config.cookieJar,
      userAgent: config.userAgent,
      agent: config.agent,
      agentClass: config.agentClass,
      agentOptions: config.agentOptions
    };

    const fragment = whatwgURL.parseURL(config.url).fragment;

    return resourceLoader.download(config.url, options, (err, responseText, res) =&#x3e; {
      if (err) {
        reportInitError(err, config);
        return;
      }

      // The use of `res.request.uri.href` ensures that `window.location.href`
      // is updated when `request` follows redirects.
      config.html = responseText;
      config.url = res.request.uri.href;
      if (fragment) {
        config.url += `#${fragment}`;
      }

      if (res.headers[&#x22;last-modified&#x22;]) {
        config.lastModified = new Date(res.headers[&#x22;last-modified&#x22;]);
      }

      const contentType = parseContentType(res.headers[&#x22;content-type&#x22;]);
      if (config.parsingMode === &#x22;auto&#x22;) {
        if (contentType.isXML()) {
          config.parsingMode = &#x22;xml&#x22;;
        }
      }
      config.encoding = contentType.get(&#x22;charset&#x22;);

      processHTML(config);
    });
  }
  return req;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

You can use it with a URL

```js
// Count all of the links from the io.js build page
var jsdom = require(&#x22;jsdom&#x22;);

jsdom.<span class="apidocCodeKeywordSpan">env</span>(
  &#x22;https://iojs.org/dist/&#x22;,
  [&#x22;http://code.jquery.com/jquery.js&#x22;],
  function (err, window) {
    console.log(&#x22;there have been&#x22;, window.$(&#x22;a&#x22;).length - 4, &#x22;io.js releases!&#x22;);
  }
);
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdom.evalVMScript" id="apidoc.module.jsdom.evalVMScript">module jsdom.evalVMScript</a></h1>


    <h2>
        <a href="#apidoc.element.jsdom.evalVMScript.evalVMScript" id="apidoc.element.jsdom.evalVMScript.evalVMScript">
        function <span class="apidocSignatureSpan">jsdom.</span>evalVMScript
        <span class="apidocSignatureSpan">(window, script)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(window, script) =&#x3e; {
  return script.runInContext(idlUtils.implForWrapper(window._document)._global);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Running vm scripts

Although in most cases it&#x27;s simplest to just insert a `&#x3c;script&#x3e;` element or call `window.eval`, in some cases you
 want access to the raw [vm context](https://nodejs.org/api/vm.html) underlying jsdom to run scripts. You can do that like so:

```js
const script = new vm.Script(&#x22;globalVariable = 5;&#x22;, { filename: &#x22;test.js&#x22; });
jsdom.<span class="apidocCodeKeywordSpan">evalVMScript</span>(window, script);
```

## jsdom vs. PhantomJS

Some people wonder what the differences are between jsdom and [PhantomJS](http://phantomjs.org/), and when you would use one over
 the other. Here we attempt to explain some of the differences, and why we find jsdom to be a pleasure to use for testing and scraping
 use cases.

PhantomJS is a complete browser (although it uses a very old and rare rendering engine). It even performs layout and rendering,
allowing you to query element positions or take a screenshot. jsdom is not a full browser: it does not perform layout or rendering
, and it does not support navigation between pages. It _does_ support the DOM, HTML, canvas, many other web platform APIs, and running
 scripts.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdom.getVirtualConsole" id="apidoc.module.jsdom.getVirtualConsole">module jsdom.getVirtualConsole</a></h1>


    <h2>
        <a href="#apidoc.element.jsdom.getVirtualConsole.getVirtualConsole" id="apidoc.element.jsdom.getVirtualConsole.getVirtualConsole">
        function <span class="apidocSignatureSpan">jsdom.</span>getVirtualConsole
        <span class="apidocSignatureSpan">(window)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getVirtualConsole = function (window) {
  return window._virtualConsole;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  virtualConsole: virtualConsole
});
```

Post-initialization, if you didn&#x27;t pass in a `virtualConsole` or no longer have a reference to it, you can retrieve the `virtualConsole
` by using:

```js
var virtualConsole = jsdom.<span class="apidocCodeKeywordSpan">getVirtualConsole</span>(window);
```

#### Virtual console `jsdomError` error reporting

Besides the usual events, corresponding to `console` methods, the virtual console is also used for reporting errors from jsdom itself
. This is similar to how error messages often show up in web browser consoles, even if they are not initiated by `console.error`.
So far, the following errors are output this way:

- Errors loading or parsing external resources (scripts, stylesheets, frames, and iframes)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdom.jQueryify" id="apidoc.module.jsdom.jQueryify">module jsdom.jQueryify</a></h1>


    <h2>
        <a href="#apidoc.element.jsdom.jQueryify.jQueryify" id="apidoc.element.jsdom.jQueryify.jQueryify">
        function <span class="apidocSignatureSpan">jsdom.</span>jQueryify
        <span class="apidocSignatureSpan">(window, jqueryUrl, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jQueryify = function (window, jqueryUrl, callback) {
  if (!window || !window.document) {
    return;
  }

  const implImpl = idlUtils.implForWrapper(window.document.implementation);
  const features = implImpl._features;
  implImpl._addFeature(&#x22;FetchExternalResources&#x22;, [&#x22;script&#x22;]);
  implImpl._addFeature(&#x22;ProcessExternalResources&#x22;, [&#x22;script&#x22;]);

  const scriptEl = window.document.createElement(&#x22;script&#x22;);
  scriptEl.className = &#x22;jsdom&#x22;;
  scriptEl.src = jqueryUrl;
  scriptEl.onload = scriptEl.onerror = () =&#x3e; {
    implImpl._features = features;

    if (callback) {
      callback(window, window.jQuery);
    }
  };

  window.document.body.appendChild(scriptEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### jQueryify

```js
var jsdom = require(&#x22;jsdom&#x22;);
var window = jsdom.jsdom().defaultView;

jsdom.<span class="apidocCodeKeywordSpan">jQueryify</span>(window, &#x22;http://code.jquery.com/jquery-2.1.1.js&#x22;, function () {
  window.$(&#x22;body&#x22;).append(&#x27;&#x3c;div class=&#x22;testing&#x22;&#x3e;Hello World, It works&#x3c;/div&#x3e;&#x27;);

  console.log(window.$(&#x22;.testing&#x22;).text());
});
```

### Passing objects to scripts inside the page
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdom.jsdom" id="apidoc.module.jsdom.jsdom">module jsdom.jsdom</a></h1>


    <h2>
        <a href="#apidoc.element.jsdom.jsdom.jsdom" id="apidoc.element.jsdom.jsdom.jsdom">
        function <span class="apidocSignatureSpan">jsdom.</span>jsdom
        <span class="apidocSignatureSpan">(html, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsdom = function (html, options) {
  if (options === undefined) {
    options = {};
  }
  if (options.parsingMode === undefined || options.parsingMode === &#x22;auto&#x22;) {
    options.parsingMode = &#x22;html&#x22;;
  }

  if (options.parsingMode !== &#x22;html&#x22; &#x26;&#x26; options.parsingMode !== &#x22;xml&#x22;) {
    throw new RangeError(`Invalid parsingMode option ${JSON.stringify(options.parsingMode)}; must be either &#x22;html&#x22;, ` +
      `&#x22;xml&#x22;, &#x22;auto&#x22;, or undefined`);
  }

  options.encoding = options.encoding || &#x22;UTF-8&#x22;;

  setGlobalDefaultConfig(options);

  // Back-compat hack: we have previously suggested nesting these under document, for jsdom.env at least.
  // So we need to support that.
  if (options.document) {
    if (options.document.cookie !== undefined) {
      options.cookie = options.document.cookie;
    }
    if (options.document.referrer !== undefined) {
      options.referrer = options.document.referrer;
    }
  }

  // List options explicitly to be clear which are passed through
  const window = new Window({
    parsingMode: options.parsingMode,
    contentType: options.contentType,
    encoding: options.encoding,
    parser: options.parser,
    url: options.url,
    lastModified: options.lastModified,
    referrer: options.referrer,
    cookieJar: options.cookieJar,
    cookie: options.cookie,
    resourceLoader: options.resourceLoader,
    deferClose: options.deferClose,
    concurrentNodeIterators: options.concurrentNodeIterators,
    virtualConsole: options.virtualConsole,
    pool: options.pool,
    agent: options.agent,
    agentClass: options.agentClass,
    agentOptions: options.agentOptions,
    strictSSL: options.strictSSL,
    proxy: options.proxy,
    userAgent: options.userAgent
  });

  const documentImpl = idlUtils.implForWrapper(window.document);
  documentFeatures.applyDocumentFeatures(documentImpl, options.features);

  if (options.created) {
    options.created(null, window.document.defaultView);
  }

  if (options.parsingMode === &#x22;html&#x22;) {
    if (html === undefined || html === &#x22;&#x22;) {
      html = &#x22;&#x3c;html&#x3e;&#x3c;head&#x3e;&#x3c;/head&#x3e;&#x3c;body&#x3e;&#x3c;/body&#x3e;&#x3c;/html&#x3e;&#x22;;
    }

    window.document.write(html);
  } else if (options.parsingMode === &#x22;xml&#x22;) {
    if (html !== undefined) {
      documentImpl._htmlToDom.appendHtmlToDocument(html, documentImpl);
    }
  }

  if (window.document.close &#x26;&#x26; !options.deferClose) {
    window.document.close();
  }

  return window.document;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Dealing with asynchronous script loading

If you load scripts asynchronously, e.g. with a module loader like RequireJS, none of the above hooks will really give you what
you want. There&#x27;s nothing, either in jsdom or in browsers, to say &#x22;notify me after all asynchronous loads have completed
.&#x22; The solution is to use the mechanisms of the framework you are using to notify about this finishing up. E.g., with RequireJS
, you could do

```js
// On the Node.js side:
var window = jsdom.<span class="apidocCodeKeywordSpan">jsdom</span>(...).defaultView;
window.onModulesLoaded = function () {
  console.log(&#x22;ready to roll!&#x22;);
};
```

```html
&#x3c;!-- Inside the HTML you supply to jsdom --&#x3e;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdom.jsdom.env" id="apidoc.element.jsdom.jsdom.env">
        function <span class="apidocSignatureSpan">jsdom.jsdom.</span>env
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">env = function () {
  const config = getConfigFromArguments(arguments);
  let req = null;

  if (config.file &#x26;&#x26; canReadFilesFromFS) {
    req = resourceLoader.readFile(config.file,
    { defaultEncoding: config.defaultEncoding, detectMetaCharset: true },
    (err, text, res) =&#x3e; {
      if (err) {
        reportInitError(err, config);
        return;
      }

      const contentType = parseContentType(res.headers[&#x22;content-type&#x22;]);
      config.encoding = contentType.get(&#x22;charset&#x22;);
      setParsingModeFromExtension(config, config.file);

      config.html = text;
      processHTML(config);
    });
  } else if (config.html !== undefined) {
    processHTML(config);
  } else if (config.url) {
    req = handleUrl(config);
  } else if (config.somethingToAutodetect !== undefined) {
    const url = URL.parse(config.somethingToAutodetect);
    if (url.protocol &#x26;&#x26; url.hostname) {
      config.url = config.somethingToAutodetect;
      req = handleUrl(config.somethingToAutodetect);
    } else if (canReadFilesFromFS) {
      req = resourceLoader.readFile(config.somethingToAutodetect,
      { defaultEncoding: config.defaultEncoding, detectMetaCharset: true },
      (err, text, res) =&#x3e; {
        if (err) {
          if (err.code === &#x22;ENOENT&#x22; || err.code === &#x22;ENAMETOOLONG&#x22;) {
            config.html = config.somethingToAutodetect;
            processHTML(config);
          } else {
            reportInitError(err, config);
          }
        } else {
          const contentType = parseContentType(res.headers[&#x22;content-type&#x22;]);
          config.encoding = contentType.get(&#x22;charset&#x22;);
          setParsingModeFromExtension(config, config.somethingToAutodetect);

          config.html = text;
          config.url = toFileUrl(config.somethingToAutodetect);
          processHTML(config);
        }
      });
    } else {
      config.html = config.somethingToAutodetect;
      processHTML(config);
    }
  }

  function handleUrl() {
    config.cookieJar = config.cookieJar || exports.createCookieJar();

    const options = {
      defaultEncoding: config.defaultEncoding,
      detectMetaCharset: true,
      headers: config.headers,
      pool: config.pool,
      strictSSL: config.strictSSL,
      proxy: config.proxy,
      cookieJar: config.cookieJar,
      userAgent: config.userAgent,
      agent: config.agent,
      agentClass: config.agentClass,
      agentOptions: config.agentOptions
    };

    const fragment = whatwgURL.parseURL(config.url).fragment;

    return resourceLoader.download(config.url, options, (err, responseText, res) =&#x3e; {
      if (err) {
        reportInitError(err, config);
        return;
      }

      // The use of `res.request.uri.href` ensures that `window.location.href`
      // is updated when `request` follows redirects.
      config.html = responseText;
      config.url = res.request.uri.href;
      if (fragment) {
        config.url += `#${fragment}`;
      }

      if (res.headers[&#x22;last-modified&#x22;]) {
        config.lastModified = new Date(res.headers[&#x22;last-modified&#x22;]);
      }

      const contentType = parseContentType(res.headers[&#x22;content-type&#x22;]);
      if (config.parsingMode === &#x22;auto&#x22;) {
        if (contentType.isXML()) {
          config.parsingMode = &#x22;xml&#x22;;
        }
      }
      config.encoding = contentType.get(&#x22;charset&#x22;);

      processHTML(config);
    });
  }
  return req;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

You can use it with a URL

```js
// Count all of the links from the io.js build page
var jsdom = require(&#x22;jsdom&#x22;);

jsdom.<span class="apidocCodeKeywordSpan">env</span>(
  &#x22;https://iojs.org/dist/&#x22;,
  [&#x22;http://code.jquery.com/jquery.js&#x22;],
  function (err, window) {
    console.log(&#x22;there have been&#x22;, window.$(&#x22;a&#x22;).length - 4, &#x22;io.js releases!&#x22;);
  }
);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdom.jsdom.jQueryify" id="apidoc.element.jsdom.jsdom.jQueryify">
        function <span class="apidocSignatureSpan">jsdom.jsdom.</span>jQueryify
        <span class="apidocSignatureSpan">(window, jqueryUrl, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jQueryify = function (window, jqueryUrl, callback) {
  if (!window || !window.document) {
    return;
  }

  const implImpl = idlUtils.implForWrapper(window.document.implementation);
  const features = implImpl._features;
  implImpl._addFeature(&#x22;FetchExternalResources&#x22;, [&#x22;script&#x22;]);
  implImpl._addFeature(&#x22;ProcessExternalResources&#x22;, [&#x22;script&#x22;]);

  const scriptEl = window.document.createElement(&#x22;script&#x22;);
  scriptEl.className = &#x22;jsdom&#x22;;
  scriptEl.src = jqueryUrl;
  scriptEl.onload = scriptEl.onerror = () =&#x3e; {
    implImpl._features = features;

    if (callback) {
      callback(window, window.jQuery);
    }
  };

  window.document.body.appendChild(scriptEl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### jQueryify

```js
var jsdom = require(&#x22;jsdom&#x22;);
var window = jsdom.jsdom().defaultView;

jsdom.<span class="apidocCodeKeywordSpan">jQueryify</span>(window, &#x22;http://code.jquery.com/jquery-2.1.1.js&#x22;, function () {
  window.$(&#x22;body&#x22;).append(&#x27;&#x3c;div class=&#x22;testing&#x22;&#x3e;Hello World, It works&#x3c;/div&#x3e;&#x27;);

  console.log(window.$(&#x22;.testing&#x22;).text());
});
```

### Passing objects to scripts inside the page
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdom.nodeLocation" id="apidoc.module.jsdom.nodeLocation">module jsdom.nodeLocation</a></h1>


    <h2>
        <a href="#apidoc.element.jsdom.nodeLocation.nodeLocation" id="apidoc.element.jsdom.nodeLocation.nodeLocation">
        function <span class="apidocSignatureSpan">jsdom.</span>nodeLocation
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nodeLocation = function (node) {
  return idlUtils.implForWrapper(node)[locationInfo];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  &#x3c;/p&#x3e;`);

var bodyEl = document.body; // implicitly created
var pEl = document.querySelector(&#x22;p&#x22;);
var textNode = pEl.firstChild;
var imgEl = document.querySelector(&#x22;img&#x22;);

console.log(jsdom.<span class="apidocCodeKeywordSpan">nodeLocation</span>(bodyEl));   // null; it&#x27;s not in the source
console.log(jsdom.nodeLocation(pEl));      // { start: 0, end: 39, startTag: ..., endTag: ... }
console.log(jsdom.nodeLocation(textNode)); // { start: 3, end: 13 }
console.log(jsdom.nodeLocation(imgEl));    // { start: 13, end: 32 }
```

This returns the [parse5 location info](https://www.npmjs.com/package/parse5#options-locationinfo) for the node.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdom.reconfigureWindow" id="apidoc.module.jsdom.reconfigureWindow">module jsdom.reconfigureWindow</a></h1>


    <h2>
        <a href="#apidoc.element.jsdom.reconfigureWindow.reconfigureWindow" id="apidoc.element.jsdom.reconfigureWindow.reconfigureWindow">
        function <span class="apidocSignatureSpan">jsdom.</span>reconfigureWindow
        <span class="apidocSignatureSpan">(window, newProps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reconfigureWindow = function (window, newProps) {
  if (&#x22;top&#x22; in newProps) {
    window._top = newProps.top;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
This returns the [parse5 location info](https://www.npmjs.com/package/parse5#options-locationinfo) for the node.

#### Overriding `window.top`

The `top` property on `window` is marked `[Unforgeable]` in the spec, meaning it is a non-configurable own property and thus cannot
 be overridden or shadowed by normal code running inside the jsdom window, even using `Object.defineProperty`. However, if you&#
x27;re acting from outside the window, e.g. in some test framework that creates jsdom instances, you can override it using the special
 `jsdom.reconfigureWindow` function:

```js
jsdom.<span class="apidocCodeKeywordSpan">reconfigureWindow</span>(window, { top: myFakeTopForTesting });
```

In the future we may expand `reconfigureWindow` to allow overriding other `[Unforgeable]` properties. Let us know if you need this
 capability.

#### Changing the URL of an existing jsdom `Window` instance

At present jsdom does not handle navigation (such as setting `window.location.href === &#x22;https://example.com/&#x22;`). However
, if you&#x27;d like to change the URL of an existing `Window` instance (such as for testing purposes), you can use the `jsdom.changeURL
` method:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdom.serializeDocument" id="apidoc.module.jsdom.serializeDocument">module jsdom.serializeDocument</a></h1>


    <h2>
        <a href="#apidoc.element.jsdom.serializeDocument.serializeDocument" id="apidoc.element.jsdom.serializeDocument.serializeDocument">
        function <span class="apidocSignatureSpan">jsdom.</span>serializeDocument
        <span class="apidocSignatureSpan">(doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeDocument = function (doc) {
  return domToHtml([doc]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
